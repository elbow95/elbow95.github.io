---
layout: post
title: C++中的内存管理和链接
date: '2020-01-15'
categories: [C++, Interview]
---

## C++内存分配

- 计算机中的程序内存分布图如下图所示

<div class="image-wrapper" style="text-align: center">
<img src="..\assets\post\2020-01-15\memory.png" alt="img" style="zoom:40%;" />
</div>

- 栈（Stack）：由编译器自动分配和释放，存放函数运行时分配的**局部变量（包括局部常量，不可修改性由编译器保证，可以`const_cast`）、函数参数值、返回数据、返回地址**等。操作类似于数据结构中的栈
- 动态链接库：用于在程序运行期间加载和卸载动态链接库
- 堆（Heap）：一般**由程序员分配**，如果程序员没有释放，程序结束时可能由操作系统回收。`malloc(),calloc(),free()`操作的就是这块内存
- 全局数据区（global data）：存放**全局变量、静态变量（包括静态局部和静态全局）**等，这块内存有读写权限，因此他们的值在程序运行期间可以任意改变。程序结束之后由系统释放
- 常量区（文字常量区）：存放**一般的常量、常量字符串**，这块内存只有读权限，因此在运行期间不能改变。程序结束后由系统释放
- 代码区：存放函数体的二进制代码

```c++
#include <stdio.h>
char *str1 = "hello word";	//字符串在常量区，str1在全局数据区
int n;	// 全局数据区
char* fun(){
	char* str = "hello world";	//字符串在常量区，str在栈区
	return str;
}
int main(){
	int a;	//栈
	char *str2 = "01234";	//字符串在常量区，str2在栈区
	char arr[20] = "56789";	//字符串和arr都在栈区
	char *pstr = fun();	//栈
	static int c = 0;	//全局数据区
	char *p1 = (char*)malloc(10);	//p1在栈区，分配的10字节的堆区
	strcpy(p1, "01234");	//01234在常量区，编译器可能会将它与str2指向的"01234"优化为一个地方
	
	reutrn 0;
}
```

### 三种内存分配方式

- 从全局数据区分配：内存在程序编译的时候已经分配好，这块内存在程序的整个运行期间都存在，例如全局变量，静态变量
- 在栈上分配：在执行函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束后，这些内存单元会自动被释放；栈内存分配运算内置于处理器的指令集，效率高，但是分配的内存容量有限
- 从堆上分配：动态内存分配，程序在运行的时候使用malloc或者new申请的内存，程序自行负责何时用free或者delete释放内存。在堆上申请空间，有责任回收它，否则会出现内存泄漏

## 堆和栈的区别

- 碎片问题：堆，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低；栈没有这个问题
- 生长方向：堆向上；栈向下
- 分配方式：堆是动态分配的，没有静态分配的堆；栈有两种方式：静态分配由编译器完成，比如全局变量的分配，动态分配由`alloca`函数进行，但是栈的动态分配由编译器进行释放，无需手动操作
- 分配效率：堆的分配是c/c++函数库提供的，机制很复杂，为了分配一块内存，库函数首先会搜索有没有足够大的空间，如果没有就调用系统功能增加程序数据段的内存空间然后返回；栈式机器系统提供的数据结构，计算机在底层对栈提供支持，比如分配专门的寄存去存放栈的地址，压栈和出栈都有专门的指令执行，所以栈的效率很高
- 管理方式：堆由程序员手动申请和释放；栈由编译器进行管理

```c++
//下式表示new在堆上申请一块内存，然后在栈中存放一个指向这块堆内存的指针p
int* p = new int[6];
```



## 内存管理

- `malloc`：申请指定字节数的内存。申请到的内存中的初始值不确定
- `calloc`：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0
- `realloc`：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定
- `alloca`：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，`alloca`不具可移植性, 而且在没有传统堆栈的机器上很难实现。`alloca`不宜使用在必须广泛移植的程序中

### malloc和free

- 用于分配、释放内存

```c++
//申请内存，并确认申请是否成功
char *str = (char*)malloc(100);
assert(str!=nullptr);
//释放内存并置空指针
free(p);
p = nullptr;
```

## new和delete

- `new/new[]`：完成两件事，先底层调用`malloc`分配了内存，然后调用构造函数（创建对象）
- `delete/delete[]`：也完成两件事，先调用析构函数（清理资源），然后底层调用`free`释放空间
- `new`在申请内存时会自动计算所需字节数，而`malloc`则需要我们自己输入申请内存空间的字节数

```c++
T* t = new T();
delete t;
```

## 定位new（placement new）

- 允许向`new`传递额外的地址参数，从而在预先指定的内存区域创建对象

```c++
new (place_address) type
new (place_address) type (initializers)
new (place_address) type [size]
new (place_address) type [size] {braced initializer list}
```

- `place_address`是一个指针
- `initializers`提供一个（可能为空）以逗号分隔的初始值列表

> delete this 合法吗？
>
> - 合法，但是
>   - 必须保证 this 对象是通过 `new`（不是 `new[]`、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的
>   - 必须保证调用 `delete this` 的成员函数是最后一个调用 this 的成员函数
>   - 必须保证成员函数的 `delete this` 后面没有调用 this 了
>   - 必须保证 `delete this` 后没有人使用了

## 如何定义一个只能在堆上（栈上）生成对象的类？

### 只能在堆上

- 方法：将析构函数设置为私有
- 原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象

### 只能在栈上

- 方法：将new和delete设置为私有
- 原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象



## 编译与链接

```c++
#include <stdio.h>
int main(){
	print("Hello world!");
	return 0;
}
```

- 在Unix系统中，由编译器把源文件转换为目标文件

```shell
gcc -o hello hello.c
g++ -o hello hello.cpp
```

<div class="image-wrapper" style="text-align: center">
<img src="..\assets\post\2020-01-15\compile.png" alt="img" style="zoom:60%;" />
</div>

- 预处理阶段：处理以`#`开头的预处理命令，生成`.i/.ii`文件

- ```shell
  g++ -E hello.cpp -o hello.i
  ```

- 编译阶段：编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化等，生成`.s`汇编文件

- ```shell
  g++ -S hello.cpp -o hello.s
  ```

- 汇编阶段：汇编器将汇编码生成机器码，生成`.o`目标文件

- ```shell
  g++ -c hello.cpp -o test.o
  ```

- 链接：链接器进行地址和空间分配、符号决议、重定位等，生成`.out`可执行目标程序

- ```shell
  ld -o hello.out hello.o ...libraries...
  ```

### 目标文件存储结构

- `File Header`：文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）
- `.text section`：代码段，执行语句编译成的机器代码
- `.data section`：数据段，已初始化的全局变量和局部静态变量
- `.bss section`：BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）
- `.rodate section`：只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量
- `comment section`：注释信息段，存放编译器版本信息
- `.note.GNU-stack section`：堆栈提示段

### 静态链接

- 静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：
  - 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来
  - 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置

<div class="image-wrapper" style="text-align: center">
<img src="..\assets\post\2020-01-15\staticlink.png" alt="img" style="zoom:80%;" />
</div>

### 动态链接

- 静态链接有以下两个问题：
  - 当静态库更新时那么整个程序都要重新进行链接；
  - 对于`printf`这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。
- 共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：
  - 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；
  - 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。

<div class="image-wrapper" style="text-align: center">
<img src="..\assets\post\2020-01-15\dynamiclink.png" alt="img" style="zoom:80%;" />
</div>

### 链接的接口-符号

- 在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。