---
layout: post
title: C++面向对象特性
date: '2020-01-13'
categories: [C++, Interview]
---

面向对象程序设计（Object-Oriented Programming, OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。

<div class="image-wrapper" style="text-align: center">
<img src="..\assets\post\2020-01-13\OOP.png" alt="img" style="zoom:100%;" />
</div>

面向对象三大特性：封装(Encapsulation)，继承(Inheritance)，多态(Polymorphism)

## 封装（Encapsulation）

- 把客观事物**封装成抽象的类**，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏
  - `public`成员：可以被**任意实体**访问
  - `protected`成员：只允许被**子类和本类的成员函数**访问
  - `private`成员：只允许被**本类的成员函数、友元类或者友元函数**访问

## 继承（Inheritance）

- 基类（父类）——>派生类（子类）

## 多态（Encapsulation）

- 多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力
- 多态是以封装和继承为基础的
- C++ 多态分类及实现：
  - **重载多态**（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载
  - **子类型多态**（Subtype Polymorphism，运行期）：虚函数
  - **参数多态性**（Parametric Polymorphism，编译期）：类模板、函数模板
  - **强制多态**（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换

### 静态多态（编译期/早绑定）

- 函数重载

```c++
class A{
public:
	void fun(int a);
	voif fun(int a, int b);
};
```

### 动态多态（运行期/晚绑定）

- 虚函数：使用`virtual`修饰成员函数，使其成为虚函数
  - 普通函数（非类成员函数）不能是虚函数
  - 静态函数（`static`）不能是虚函数
  - **构造函数不能是虚函数**（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成才会形成虚表指针）
  - 内联函数不能是表现多态时的虚函数

### 虚析构函数

- 析构函数可以是虚函数，是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象（删除基类指针时会调用派生类析构函数，防止基类指针无法释放派生类内存资源）
- 用来做基类的类的析构函数一般都是虚析构函数

## 虚函数，纯虚函数

- 纯虚函数一种特殊的虚函数，在基类中不能对虚函数做出有意义的实现，而把他声明为纯虚函数，他的实现留给该基类的派生类去做

```c++
virtual int A() = 0;
```

- 类中如果声明了虚函数，那么这个函数是实现的，哪怕是空实现，他的作用就是为了能让这个函数在他的子类中可以被覆盖(override)，这样就可以使用晚绑定实现多态了。纯虚函数是一个接口，是个函数的声明而已，要留到子类里面实现
- 虚函数在子类里面可以不进行重写；纯虚函数必须在子类实现才可以实例化子类
- 虚函数的类用于”继承“，继承接口的同时也继承了父类的实现；纯虚函数关注的是接口的统一性，实现由子类完成
- 带纯虚函数的类被称为抽象类，这种类不能直接生成对象，而只能被被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类
- 虚基类是虚继承中的基类

## 虚函数指针、虚函数表

- 虚函数指针（Virtual Function Pointer, `vfptr`）：在含有虚函数类的对象中，指向虚函数表，在运行时确定
- 虚函数表（Virtual Function Table）：在程序只读数据段（`.rodata section`），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建

```c++
class base1{
public:
	int base1_1;
	int base1_2;
	virtual void base1_fun1(){}
	virtual void base1_fun2(){}
};
class derived1:public base1{
public:
	int derive1_1;
	int derive1_2;
};
```

- 上述的派生类的虚函数表指针为：

<div class="image-wrapper" style="text-align: center">
<img src="..\\assets\post\2020-01-13\vfptr.png" alt="img" style="zoom:100%;" />
</div>

## 虚继承

- 虚继承用于解决多继承条件下的**菱形继承问题**（浪费存储空间、存在二义性）
- 底层实现原理与编译器相关，一般通过**虚基类指针**和**虚基类表**实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承
- 实际上，`vbptr` 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。

## 虚继承和虚函数

- 相同之处：都使用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）
- 不同之处：
  - 虚继承：
    - 虚基类依旧存在派生类中，只占用存储空间
    - 虚基类表存储的是虚基类相对直接继承类的偏移
  - 虚函数：
    - 虚函数不占用存储空间
    - 虚函数表存储的是虚函数地址

## 模板类、成员模板、虚函数

- 模板类可以使用虚函数
- 一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数

## 抽象类、接口类、聚合类

- 抽象类：含有纯虚函数的类
- 接口类：仅含有纯虚函数的抽象类
- 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
  - 所有成员都是 public
  - 没有定义任何构造函数
  - 没有类内初始化
  - 没有基类，也没有 virtual 函数