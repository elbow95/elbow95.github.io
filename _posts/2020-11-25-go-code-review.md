---
layout: post
title: Go代码编程规范
data: '2020-11-24'
categories: [Go]
---

### gofmt命令

- 使用`gofmt`命令会自动修复大多数代码缩进等风格问题

### 注释

- 注释文档声明应该是一个完整的句子，即使看起来有些多与，这种方式使注释在提取到godoc文档时格式良好。注释应当以所描述事物的名称开头，并以句号结束

### 声明空切片

- 当声明一个切片的时候，优先使用`var t []string`而不是`t := []string{}`，前者声明了一个nil切片，而后者声明了一个非nil但是零长度的切片。这种形式可以避免不添加数据的时候分配内存。

### 文档注释

- 所有顶级导出名称都应该具有文档注释。

### 不要使用panic

- 不要对正常的错误使用panic，应当使用error和多返回值。

### 错误信息

- 错误信息不应该大写（除非以专有名词或者缩写开头）或者标点符号结束，因为他们通常是在其他上下文之后打印的

### 处理错误

- 不要使用`_`忽略error返回值，如果一个函数会返回error值，检查返回确定函数是否执行成功。

### 导入

- 导入是按组组织的，他们之间有空白行，标准的库软件包在第一组中

### 导入`.`

- 部分包由于循环依赖，不能作为测试包的一部分进行测试时，以`import .`的形式导入会很有用

```go
package foo_test

import (
    "bar/testutil"
    . "foo"
)
```

- 在上面代码中，测试文件不能位于foo包中，因为它使用的`bar/testutil`依赖于foo包。


### 错误流缩进

- 处理错误的时候优先使用这种形式：

```go
if err != nil{
    // error handling
    return
}
// normal code
```

```go
x, err := f()
if err != nil{
    // error handling
    return
}
// use x
```

### 首字母缩写

- 名称中的单词是首字母或者首字母缩略词（例如`URL`或者`NATO`）需要具有相同的大小写规则。例如应当使用`URL`或者`url`而不是`Url`；使用`ServeHTTP`而不是`ServeHttp`

- 由协议缓冲区编译期生成的代码不受此规则的约束。

### 行长度

- Go代码中没有严格的行长限制，但为了避免造成阅读障碍，最好不要使用长行；但是如果长行的可读性更好，不要为了缩短行长而使用换行符。

- 长行可能与长名称有关，因此应当避免名称过长。

### 命名返回参数

```go
// 使用这种方式进行参数返回
func (n *Node) Parent1() *Node
func (n *Node) Parent2() (*Node, err)
```

- 对于返回两个或者以上个数类型相同的采纳书，或者如果在上下文中不清楚返回结果的含义，那么在某些上下文中添加命名会有用

- 如果函数行较少，那么非命名返回参数是可以的，但是一旦它是一个中等规模的函数，需要明确返回值

### 包注释

- 与`godoc`中呈现的所有注释一样，包注释必须出现在包声明的邻近位置，并且不能存在空行

```go
// Package math provides basic conxtants and mathematical functions
package math

/*
...
*/
package template
```

- 对于`package main`的注释，在二进制文件名称之后可以使用其他样式的注释

- 注意以小写单词开头的句子不属于包注释的可接受选项，因为注释是公开可见的，应当用适当的英语书写，包括将句子的第一个单词的首字母大写

### 包名称

- 包中名称的所有引用都使用包名完成的，因此可以从定义的标识符中省略包名。例如使用`chubby.File`而不是`chubby.ChubbyFile`

- 避免使用无意义的包名称

### 传参

- 不要为了节省几个字节的存储空间就将指针作为函数参数传递。

- 如果一个函数在整个过程中只引用了它的参数x作为x，这时候这个参数不应该是一个指针。这种情况下值本身都是固定大小，可以直接传递

### 方法接收者名称

- 方法接收者的名称应当可以反映其身份；通常，使用其类型的一个或者两个字母缩写就足够；同时不要使用通用名称比如`me`或者`this`等

### 方法接收者类型

- 选择在方法上使用值接收者还是指针接收者是一个难题

- 如果对使用哪种方式有疑问就直接使用指针接收者；但是有是出于效率的考虑值接收者才有意义

- 一些选择的经验
 - 如果接受者是`map,func, chan`等，则不要使用值向他们的指针；如果接收者是`slice`并且该方法不重新切片或者不重新分配切片，不要使用指向他们的指针
 - 如果该方法需要改变接收者的类型，使用指针
 - 如果接受者包含`sync.Mutex`或者类似同步字段的结构体，必须使用避免复制的指针
 - 如果接收者是大型结构或者数组，使用指向它的指针更有效
 - 当在调用方法时，值类型会创建接收者的副本，因此在外部更新时，内部无法看到更新。如果必须在内部看到更新，就必须使用指针
 - 如果接收者是`struct,array,slice`，并且其任何元素是指向可能改变的对象的指针，则更倾向于使用指针
 - 如果接收者是一个小型数组或者`struct`，那么应当使用值类型；对于没有可变字段，并且没有指针的类型，或者一个简单的基础类型，使用值接收者。
 - 值接收者可以减少生成的垃圾量；如果将值作为参数传递给值类型方法，则可以使用堆栈上的副本而不需要在堆上进行分配


### 有用的测试错误语句

- 错误测试有助于提供有用的信息，说明错误，展示输入内容，实际内容以及预期结果。

```go
if got != tt.want{
    t.Errorf("Foo(%q) = %d; want %d", tt.in, got, tt.want)
}
```

- 编写`assertFoo`可以产生有用的错误信息

### 变量名称

- 变量名称宜短不宜长，对于范围有限的局部变量更是如此。

- 变量命名基本规则：使用变量的地方距离声明位置越远，名称就必须越具有描述性；对于方法接收者，一个或者两个字母就足够了；但是对于不常见的事物或者全局变量需要更多描述性的名称。


