---
layout: post
title: Go数组、切片和变长参数函数
date: '2020-11-17'
categories: [Go]
---

### 数组

- 不允许混合类型的数组
- 声明形式`var a [3]int`，int型数组值初始化为0
- 带初始化的声明形式`a := [3]int{1,2,3}`，没有初始化值的位置初始化为0
- `a := [...]int{1,2,3}`，自动推导数组长度
- 数组的长度也是类型的一部分，即`[n]T`整体为类型
- Go中的数组是值类型，而不是引用类型，即当赋值时，使用的是副本，当修改原数组时不会对新数组产生影响
- 当数组作为参数传递给函数时，它是按值传递，而不是引用，所以原始数组不会改变。

#### range范围形式

```go
for pos, val := range a{

}
```

- 多维数组


### 切片Slices

- 切片并不拥有自己的数组，切片只是已经存在数组的引用
- `a[start:end]`创造一个从`start`到`end-1`的数组切片
- 当多个切片同时映射到同一个数组时，每一个切片的改变都反映到原数组中
- 切片的长度就是切片内元素的个数，切片的容量(Capacity)是原数组中从切片start索引开始的元素数。
- 使用`make`创建切片`func make([]T, len, cap)`，创建的切片内所有值被默认初始化为0
- 向切片中添加数据`func append(s []T, x ...T) []T`
 - `x ...T`表示该函数接受动态数量的参数，该种函数也被称之为可变函数
 - 当向切片中添加新的数据时，会创建一个新的数组，并返回一个引用新数组的切片
- 切片类型的零值为`nil`，`nil`切片的`len`和`cap`的长度都为0

- 可以使用`...`将一个切片添加到另一个切片后`food := append(veggies, fruits...)`，`append`返回的是一个新数组引用的切片

- 在使用`append`函数时，当原`cap`不足以存储时，首先对原`cap`进行翻倍，在进行`append`

#### 将切片传递给函数

- 切片可以被看为

```go
type slice struct{
    Length      int
    Capacity    int
    ZerothElement *byte // 指向数组中的第0个元素
}
```

- 由于存储的是指向数组中元素的指针，所以当将切片传递给函数的时候，即使参数传递是以值传递的方式也会造成原属组的改变。

#### 内存优化

- 切片存储了对原数组的引用，只要切片还在内存中，系统就无法对数组进行垃圾回收。
- 当一个数组特别大，但是切片只是使用了很小的一部分
 - 解决该问题的一个方式是使用`copy`函数创建一个切片的拷贝，这样就可以使用新的切片，原数组可以执行垃圾回收
 - `func copy(dst, src []T)`

### 变长参数函数(Variadic Functions)

- 如果函数定义的最后一个参数以`...`开头，则该函数可以接受任意数量(>=0)的参数
- 只有最后一个参数可以是可变参数

```go
func test(a int, b ...int){
}
```

- 可变参数函数的工作方式是将可变数量的参数转换为可变参数类型的**切片**

- 和真实切片的区别
 - 不需要显式创建切片
 - 代码更易读

- 有一种语法糖，可以用于将切片传递给可变参数，在切片后加上省略号`...`可以直接将切片传递给函数而无须创建新的切片。

```go
func find(num int, nums ...int){
    found := false
    for i, v := range nums{
        if v == num{
            found = true
        }
    }
    if !found{
        fmt.Pringln("not found")
    }
}

func main(){
    nums := []int{89,90,95}
    // 在切片nums后面加上...可以直接传递给可变参数
    find(89, nums...)
}
```
